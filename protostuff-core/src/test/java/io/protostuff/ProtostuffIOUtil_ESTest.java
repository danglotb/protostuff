/*
 * This file was automatically generated by EvoSuite
 * Thu Apr 20 09:46:01 GMT 2017
 */

package io.protostuff;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.MockitoExtension.*;
import static org.evosuite.runtime.EvoAssertions.*;
import io.protostuff.ByteArrayInput;
import io.protostuff.ByteBufferInput;
import io.protostuff.ByteString;
import io.protostuff.CodedInput;
import io.protostuff.GraphByteArrayInput;
import io.protostuff.GraphCodedInput;
import io.protostuff.GraphProtostuffOutput;
import io.protostuff.LinkedBuffer;
import io.protostuff.LowCopyProtobufOutput;
import io.protostuff.LowCopyProtostuffOutput;
import io.protostuff.ProtobufOutput;
import io.protostuff.ProtostuffIOUtil;
import io.protostuff.ProtostuffOutput;
import io.protostuff.Schema;
import io.protostuff.WriteSession;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInput;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.FileDescriptor;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.io.PushbackInputStream;
import java.io.SequenceInputStream;
import java.io.UnsupportedEncodingException;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.mock.java.io.MockFileInputStream;
import org.evosuite.runtime.mock.java.io.MockFileOutputStream;
import org.evosuite.runtime.mock.java.io.MockPrintStream;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class ProtostuffIOUtil_ESTest extends ProtostuffIOUtil_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Integer integer0 = new Integer(128);
      Schema<Integer> schema0 = (Schema<Integer>) mock(Schema.class, new ViolatedAssumptionAnswer());
      LinkedBuffer linkedBuffer0 = new LinkedBuffer((byte[]) null, 128);
      LinkedBuffer linkedBuffer1 = new LinkedBuffer((byte[]) null, 512, 256);
      Schema<GraphCodedInput> schema1 = (Schema<GraphCodedInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      ProtostuffIOUtil.toByteArray((GraphCodedInput) null, schema1, linkedBuffer0);
      Schema<String> schema2 = (Schema<String>) mock(Schema.class, new ViolatedAssumptionAnswer());
      ProtostuffIOUtil.writeTo(linkedBuffer0, "VAzd`CJwXm`,Q9ryj0'", schema2);
      LinkedBuffer linkedBuffer2 = new LinkedBuffer(128, linkedBuffer1);
      LowCopyProtobufOutput lowCopyProtobufOutput0 = new LowCopyProtobufOutput();
      Schema<LowCopyProtobufOutput> schema3 = (Schema<LowCopyProtobufOutput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      ProtostuffIOUtil.writeTo(linkedBuffer2, lowCopyProtobufOutput0, schema3);
      LowCopyProtostuffOutput lowCopyProtostuffOutput0 = new LowCopyProtostuffOutput(lowCopyProtobufOutput0.buffer);
      Schema<LowCopyProtostuffOutput> schema4 = (Schema<LowCopyProtostuffOutput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.toByteArray(lowCopyProtostuffOutput0, schema4, linkedBuffer1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Buffer previously used and had not been reset.
         //
         verifyException("io.protostuff.ProtostuffIOUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      MockFile mockFile0 = new MockFile("io.protostuff.ProtostuffIOUtil$2", "io.protostuff.ProtostuffIOUtil$2");
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0);
      byte[] byteArray0 = new byte[9];
      byteArray0[0] = (byte)5;
      byteArray0[1] = (byte) (-1);
      byteArray0[2] = (byte) (-1);
      byteArray0[3] = (byte) (-61);
      byteArray0[4] = (byte)0;
      byteArray0[5] = (byte) (-107);
      byteArray0[6] = (byte) (-128);
      byteArray0[7] = (byte) (-1);
      byteArray0[8] = (byte) (-49);
      ByteArrayInput byteArrayInput0 = new ByteArrayInput(byteArray0, (byte) (-1), (byte)0, false);
      Schema<ByteArrayInput> schema0 = (Schema<ByteArrayInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      LinkedBuffer linkedBuffer0 = new LinkedBuffer(byteArray0, 3783);
      LinkedBuffer linkedBuffer1 = new LinkedBuffer((byte)5, linkedBuffer0);
      LinkedBuffer linkedBuffer2 = new LinkedBuffer(byteArray0, 1598, (byte) (-1), linkedBuffer1);
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.writeDelimitedTo((OutputStream) mockFileOutputStream0, byteArrayInput0, schema0, linkedBuffer2);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Buffer previously used and had not been reset.
         //
         verifyException("io.protostuff.ProtostuffIOUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("io.protostuff.ProtobufException");
      PipedInputStream pipedInputStream0 = new PipedInputStream();
      Schema<InputStream> schema0 = (Schema<InputStream>) mock(Schema.class, new ViolatedAssumptionAnswer());
      LinkedBuffer linkedBuffer0 = new LinkedBuffer((byte[]) null, 0, 21);
      LinkedBuffer linkedBuffer1 = new LinkedBuffer(0, linkedBuffer0);
      LinkedBuffer linkedBuffer2 = new LinkedBuffer((byte[]) null, 0, 256);
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.writeDelimitedTo((OutputStream) mockFileOutputStream0, (InputStream) pipedInputStream0, schema0, linkedBuffer2);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Buffer previously used and had not been reset.
         //
         verifyException("io.protostuff.ProtostuffIOUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      MockFile mockFile0 = new MockFile("(6bID7YsN+`Be-C.LRU");
      mockFile0.setWritable(true, true);
      MockFile mockFile1 = new MockFile(mockFile0, "(6bID7YsN+`Be-C.LRU");
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile1, false);
      byte[] byteArray0 = new byte[7];
      byteArray0[0] = (byte)14;
      mockFileOutputStream0.write((-1218));
      byteArray0[1] = (byte)120;
      byteArray0[2] = (byte)89;
      byteArray0[3] = (byte)4;
      byteArray0[4] = (byte)0;
      byteArray0[5] = (byte) (-8);
      byteArray0[6] = (byte)53;
      LinkedBuffer linkedBuffer0 = new LinkedBuffer((byte)53);
      LinkedBuffer linkedBuffer1 = new LinkedBuffer(byteArray0, (byte)0, (byte)120, linkedBuffer0);
      ProtostuffOutput protostuffOutput0 = new ProtostuffOutput(linkedBuffer1);
      Schema<ProtostuffOutput> schema0 = (Schema<ProtostuffOutput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.optWriteDelimitedTo((OutputStream) mockFileOutputStream0, protostuffOutput0, schema0, linkedBuffer1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Buffer previously used and had not been reset.
         //
         verifyException("io.protostuff.ProtostuffIOUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("io.protostuff.ProtostuffIOUtil$1");
      PrintStream printStream0 = mockPrintStream0.format("io.protostuff.ProtostuffIOUtil$1", (Object[]) null);
      LinkedList<CodedInput> linkedList0 = new LinkedList<CodedInput>();
      Schema<CodedInput> schema0 = (Schema<CodedInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte)0;
      byteArray0[1] = (byte)99;
      byteArray0[2] = (byte)57;
      byteArray0[3] = (byte)0;
      LinkedBuffer linkedBuffer0 = new LinkedBuffer(byteArray0, (-492), (byte)0);
      LinkedBuffer linkedBuffer1 = new LinkedBuffer(byteArray0, (byte)0, linkedBuffer0);
      ProtostuffIOUtil.writeListTo((OutputStream) printStream0, (List<CodedInput>) linkedList0, schema0, linkedBuffer1);
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(mockFileInputStream0, mockFileInputStream0);
      PushbackInputStream pushbackInputStream0 = new PushbackInputStream(sequenceInputStream0, 256);
      sequenceInputStream0.mark((byte)99);
      ByteArrayInput byteArrayInput0 = new ByteArrayInput(byteArray0, true);
      GraphByteArrayInput graphByteArrayInput0 = new GraphByteArrayInput(byteArrayInput0, 48);
      Schema<GraphByteArrayInput> schema1 = (Schema<GraphByteArrayInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      ProtostuffIOUtil.mergeFrom((InputStream) pushbackInputStream0, graphByteArrayInput0, schema1, linkedBuffer1);
      Schema<GraphByteArrayInput> schema2 = (Schema<GraphByteArrayInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.writeTo((OutputStream) mockPrintStream0, graphByteArrayInput0, schema2, linkedBuffer0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Buffer previously used and had not been reset.
         //
         verifyException("io.protostuff.ProtostuffIOUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(48);
      DataOutputStream dataOutputStream0 = new DataOutputStream(byteArrayOutputStream0);
      byte[] byteArray0 = new byte[2];
      byteArray0[0] = (byte)75;
      byteArrayOutputStream0.writeTo(dataOutputStream0);
      dataOutputStream0.writeLong((byte)62);
      byteArray0[1] = (byte)62;
      dataOutputStream0.writeBoolean(false);
      ByteArrayInput byteArrayInput0 = new ByteArrayInput(byteArray0, false);
      Schema<ByteArrayInput> schema0 = (Schema<ByteArrayInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      LinkedBuffer linkedBuffer0 = new LinkedBuffer(128);
      LinkedBuffer linkedBuffer1 = new LinkedBuffer(byteArray0, 128, (byte)62, linkedBuffer0);
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.writeTo((OutputStream) dataOutputStream0, byteArrayInput0, schema0, linkedBuffer1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Buffer previously used and had not been reset.
         //
         verifyException("io.protostuff.ProtostuffIOUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      byte[] byteArray0 = new byte[1];
      byteArray0[0] = (byte)127;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      BufferedInputStream bufferedInputStream0 = new BufferedInputStream(byteArrayInputStream0, (byte)127);
      LowCopyProtobufOutput lowCopyProtobufOutput0 = new LowCopyProtobufOutput();
      Schema<LowCopyProtobufOutput> schema0 = (Schema<LowCopyProtobufOutput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      lowCopyProtobufOutput0.writeFixed64((byte)127, (-7L), true);
      lowCopyProtobufOutput0.writeString((byte)127, "", true);
      LinkedBuffer linkedBuffer0 = new LinkedBuffer(byteArray0, (byte)127, 4);
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.optMergeDelimitedFrom((InputStream) bufferedInputStream0, lowCopyProtobufOutput0, schema0, true, linkedBuffer0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Buffer previously used and had not been reset.
         //
         verifyException("io.protostuff.ProtostuffIOUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      byte[] byteArray0 = new byte[5];
      byteArray0[0] = (byte)86;
      byteArray0[1] = (byte) (-69);
      byteArray0[2] = (byte) (-42);
      byteArray0[3] = (byte)106;
      byteArray0[4] = (byte)14;
      LinkedBuffer linkedBuffer0 = new LinkedBuffer(byteArray0, (byte) (-69), 5);
      Schema<LowCopyProtostuffOutput> schema0 = (Schema<LowCopyProtostuffOutput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      MockFile mockFile0 = new MockFile("io.protostuff.WriteSession", "io.protostuff.WriteSession");
      MockFile mockFile1 = new MockFile(mockFile0, "io.protostuff.WriteSession");
      Schema<GraphProtostuffOutput> schema1 = (Schema<GraphProtostuffOutput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream((OutputStream) null, 5);
      LinkedList<ByteBufferInput> linkedList0 = new LinkedList<ByteBufferInput>();
      Schema<ByteBufferInput> schema2 = (Schema<ByteBufferInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.writeListTo((OutputStream) bufferedOutputStream0, (List<ByteBufferInput>) linkedList0, schema2, linkedBuffer0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Buffer previously used and had not been reset.
         //
         verifyException("io.protostuff.ProtostuffIOUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      byte[] byteArray0 = new byte[2];
      byteArray0[0] = (byte)67;
      byteArray0[1] = (byte)0;
      CodedInput codedInput0 = new CodedInput(mockFileInputStream0, byteArray0, (byte)0, (byte)0, true);
      GraphCodedInput graphCodedInput0 = new GraphCodedInput(codedInput0, 5);
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.mergeDelimitedFrom((DataInput) null, graphCodedInput0, (Schema<GraphCodedInput>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("io.protostuff.IOUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      MockFile mockFile0 = new MockFile("aau-Q7JP");
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0);
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0, true);
      PrintStream printStream0 = mockPrintStream0.append((CharSequence) "aau-Q7JP", 6, 6);
      ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(printStream0);
      LinkedBuffer linkedBuffer0 = new LinkedBuffer(0);
      ProtobufOutput protobufOutput0 = new ProtobufOutput(linkedBuffer0);
      WriteSession.FlushHandler writeSession_FlushHandler0 = protobufOutput0.flushHandler;
      ProtostuffOutput protostuffOutput0 = new ProtostuffOutput(linkedBuffer0, printStream0, (WriteSession.FlushHandler) null, 7);
      GraphProtostuffOutput graphProtostuffOutput0 = new GraphProtostuffOutput(protostuffOutput0);
      Schema<GraphProtostuffOutput> schema0 = (Schema<GraphProtostuffOutput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      int int0 = ProtostuffIOUtil.writeDelimitedTo((DataOutput) objectOutputStream0, graphProtostuffOutput0, schema0);
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      LowCopyProtostuffOutput lowCopyProtostuffOutput0 = new LowCopyProtostuffOutput();
      Schema<LowCopyProtostuffOutput> schema0 = (Schema<LowCopyProtostuffOutput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      byte[] byteArray0 = new byte[2];
      byteArray0[0] = (byte)55;
      byteArray0[1] = (byte) (-101);
      LinkedBuffer linkedBuffer0 = new LinkedBuffer(byteArray0, (byte)55, (-339));
      LinkedBuffer linkedBuffer1 = new LinkedBuffer(byteArray0, (byte) (-101), (byte)55, linkedBuffer0);
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.mergeDelimitedFrom((InputStream) null, lowCopyProtostuffOutput0, schema0, linkedBuffer1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("io.protostuff.IOUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      byte[] byteArray0 = new byte[5];
      byteArray0[0] = (byte)0;
      byteArray0[1] = (byte)94;
      byteArray0[2] = (byte) (-112);
      byteArray0[3] = (byte)0;
      byteArray0[4] = (byte) (-27);
      ByteArrayInput byteArrayInput0 = new ByteArrayInput(byteArray0, (byte)94, (-1988), true);
      GraphByteArrayInput graphByteArrayInput0 = new GraphByteArrayInput(byteArrayInput0);
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.mergeFrom(byteArray0, 0, (-1988), (Object) byteArray0, (Schema<Object>) graphByteArrayInput0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("io.protostuff.GraphByteArrayInput", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("o.protostuff.ProoufException");
      PipedInputStream pipedInputStream0 = new PipedInputStream();
      Schema<InputStream> schema0 = (Schema<InputStream>) mock(Schema.class, new ViolatedAssumptionAnswer());
      LinkedBuffer linkedBuffer0 = new LinkedBuffer((byte[]) null, 0, 21);
      LinkedBuffer linkedBuffer1 = new LinkedBuffer((byte[]) null, 0, linkedBuffer0);
      int int0 = ProtostuffIOUtil.writeDelimitedTo((OutputStream) mockFileOutputStream0, (InputStream) pipedInputStream0, schema0, linkedBuffer1);
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Schema<ByteBufferInput> schema0 = (Schema<ByteBufferInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      byte[] byteArray0 = new byte[3];
      byteArray0[0] = (byte) (-55);
      byteArray0[1] = (byte)52;
      byteArray0[2] = (byte)0;
      LinkedBuffer linkedBuffer0 = new LinkedBuffer(byteArray0, 1684, 1251);
      Schema<InputStream> schema1 = (Schema<InputStream>) mock(Schema.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.writeTo(linkedBuffer0, (InputStream) null, schema1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Buffer previously used and had not been reset.
         //
         verifyException("io.protostuff.ProtostuffIOUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      byte[] byteArray0 = new byte[5];
      byteArray0[0] = (byte)86;
      byteArray0[1] = (byte) (-69);
      byteArray0[2] = (byte) (-42);
      byteArray0[3] = (byte)106;
      byteArray0[4] = (byte)14;
      LinkedBuffer linkedBuffer0 = new LinkedBuffer(byteArray0, (byte) (-69), 5);
      Schema<LowCopyProtostuffOutput> schema0 = (Schema<LowCopyProtostuffOutput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.writeTo(linkedBuffer0, (LowCopyProtostuffOutput) null, schema0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Buffer previously used and had not been reset.
         //
         verifyException("io.protostuff.ProtostuffIOUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      byte[] byteArray0 = new byte[5];
      byteArray0[0] = (byte)86;
      byteArray0[1] = (byte) (-69);
      byteArray0[2] = (byte) (-42);
      byteArray0[3] = (byte)106;
      byteArray0[4] = (byte)14;
      LinkedBuffer linkedBuffer0 = new LinkedBuffer(byteArray0, (byte) (-69), 5);
      LinkedBuffer linkedBuffer1 = new LinkedBuffer(byteArray0, (-1), linkedBuffer0);
      Schema<LowCopyProtostuffOutput> schema0 = (Schema<LowCopyProtostuffOutput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      ProtostuffIOUtil.writeTo(linkedBuffer1, (LowCopyProtostuffOutput) null, schema0);
      MockFile mockFile0 = new MockFile("io.protostuff.WriteSession", "io.protostuff.WriteSession");
      MockFile mockFile1 = new MockFile(mockFile0, "io.protostuff.WriteSession");
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile1, false);
      mockFile1.setWritable(false, false);
      ProtostuffOutput protostuffOutput0 = new ProtostuffOutput(linkedBuffer1, mockFileOutputStream0);
      GraphProtostuffOutput graphProtostuffOutput0 = new GraphProtostuffOutput(protostuffOutput0);
      Schema<GraphProtostuffOutput> schema1 = (Schema<GraphProtostuffOutput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.toByteArray(graphProtostuffOutput0, schema1, linkedBuffer0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Buffer previously used and had not been reset.
         //
         verifyException("io.protostuff.ProtostuffIOUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      Schema<GraphCodedInput> schema0 = (Schema<GraphCodedInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      byte[] byteArray0 = new byte[1];
      byteArray0[0] = (byte)0;
      LinkedBuffer linkedBuffer0 = new LinkedBuffer((byte)0);
      LinkedBuffer linkedBuffer1 = new LinkedBuffer(byteArray0, 1693, 0, linkedBuffer0);
      LinkedBuffer.allocate(923, linkedBuffer1);
      ProtostuffIOUtil.newPipe(byteArray0);
      Schema<GraphCodedInput> schema1 = (Schema<GraphCodedInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      Schema<GraphByteArrayInput> schema2 = (Schema<GraphByteArrayInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      LinkedList<CodedInput> linkedList0 = new LinkedList<CodedInput>();
      Schema<CodedInput> schema3 = (Schema<CodedInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      byte[] byteArray0 = new byte[6];
      byteArray0[0] = (byte)0;
      byteArray0[1] = (byte)111;
      byteArray0[2] = (byte)0;
      byteArray0[3] = (byte)0;
      byteArray0[4] = (byte)54;
      byteArray0[5] = (byte)74;
      Integer integer0 = new Integer((byte)54);
      Schema<Integer> schema0 = (Schema<Integer>) mock(Schema.class, new ViolatedAssumptionAnswer());
      ProtostuffIOUtil.mergeFrom(byteArray0, integer0, schema0);
      ByteArrayInput byteArrayInput0 = new ByteArrayInput(byteArray0, false);
      ByteArrayInput byteArrayInput1 = byteArrayInput0.setBounds((byte)0, 48);
      Schema<ByteArrayInput> schema1 = (Schema<ByteArrayInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      LinkedBuffer linkedBuffer0 = new LinkedBuffer(byteArray0, 3877);
      LinkedBuffer linkedBuffer1 = new LinkedBuffer(3877, linkedBuffer0);
      ProtostuffIOUtil.toByteArray(byteArrayInput1, schema1, linkedBuffer1);
      LowCopyProtobufOutput lowCopyProtobufOutput0 = new LowCopyProtobufOutput();
      Schema<LowCopyProtobufOutput> schema2 = (Schema<LowCopyProtobufOutput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.writeDelimitedTo((OutputStream) null, lowCopyProtobufOutput0, schema2, linkedBuffer1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("io.protostuff.ProtobufOutput", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(133);
      boolean boolean0 = false;
      String string0 = ByteString.EMPTY_STRING;
      byte[] byteArray0 = new byte[2];
      byteArray0[0] = (byte)48;
      byteArray0[1] = (byte) (-34);
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)48, (byte) (-34));
      PushbackInputStream pushbackInputStream0 = new PushbackInputStream(byteArrayInputStream0, 4);
      Schema<ByteBufferInput> schema0 = (Schema<ByteBufferInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      List<ByteBufferInput> list0 = ProtostuffIOUtil.parseListFrom((InputStream) pushbackInputStream0, schema0);
      Schema<ByteBufferInput> schema1 = (Schema<ByteBufferInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      LinkedBuffer linkedBuffer0 = new LinkedBuffer(byteArray0, 133);
      LinkedBuffer linkedBuffer1 = new LinkedBuffer(linkedBuffer0, linkedBuffer0);
      ProtostuffIOUtil.writeListTo((OutputStream) byteArrayOutputStream0, list0, schema1, linkedBuffer1);
      MockPrintStream mockPrintStream0 = null;
      try {
        mockPrintStream0 = new MockPrintStream(byteArrayOutputStream0, false, "");
        fail("Expecting exception: UnsupportedEncodingException");
      
      } catch(Throwable e) {
         //
         // 
         //
         verifyException("java.io.PrintStream", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      byte[] byteArray0 = new byte[7];
      byteArray0[0] = (byte)0;
      byteArray0[1] = (byte)0;
      byteArray0[2] = (byte) (-87);
      byteArray0[3] = (byte)127;
      byteArray0[4] = (byte)0;
      byteArray0[5] = (byte)0;
      CodedInput codedInput0 = CodedInput.newInstance((InputStream) null);
      try { 
        codedInput0.readSFixed32();
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // While parsing a protocol message, the input ended unexpectedly in the middle of a field.  This could mean either than the input has been truncated or that an embedded message misreported its own length.
         //
         verifyException("io.protostuff.ProtobufException", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      byte[] byteArray0 = new byte[9];
      byteArray0[0] = (byte) (-111);
      byteArray0[1] = (byte)0;
      byteArray0[3] = (byte)0;
      byteArray0[4] = (byte)0;
      byteArray0[5] = (byte)97;
      byteArray0[6] = (byte)0;
      byteArray0[7] = (byte)0;
      byteArray0[8] = (byte)62;
      ProtostuffIOUtil.newPipe(byteArray0, (-3008), 31);
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("io.protostuff.ProtostuffIOUtil$2");
      Schema<GraphCodedInput> schema0 = (Schema<GraphCodedInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      LinkedBuffer linkedBuffer0 = new LinkedBuffer(536870911);
      ProtostuffIOUtil.optWriteDelimitedTo((OutputStream) mockFileOutputStream0, (GraphCodedInput) null, schema0, linkedBuffer0);
      ProtostuffOutput protostuffOutput0 = new ProtostuffOutput(linkedBuffer0, mockFileOutputStream0);
      GraphProtostuffOutput graphProtostuffOutput0 = new GraphProtostuffOutput(protostuffOutput0, (byte)0);
      Schema<GraphProtostuffOutput> schema1 = (Schema<GraphProtostuffOutput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.optMergeDelimitedFrom((InputStream) null, graphProtostuffOutput0, schema1, true, protostuffOutput0.head);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Buffer previously used and had not been reset.
         //
         verifyException("io.protostuff.ProtostuffIOUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      ProtostuffIOUtil.newPipe((InputStream) null);
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("oNBG-.c\"_K`Rp69S)", false);
      Schema<LowCopyProtostuffOutput> schema0 = (Schema<LowCopyProtostuffOutput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte) (-79);
      byteArray0[1] = (byte)0;
      byteArray0[2] = (byte)0;
      byteArray0[3] = (byte) (-119);
      LinkedBuffer linkedBuffer0 = new LinkedBuffer(byteArray0, (-1218));
      mockFileOutputStream0.flush();
      LinkedBuffer linkedBuffer1 = new LinkedBuffer(linkedBuffer0, linkedBuffer0);
      ProtostuffIOUtil.writeTo((OutputStream) mockFileOutputStream0, (LowCopyProtostuffOutput) null, schema0, linkedBuffer1);
      Schema<LowCopyProtostuffOutput> schema1 = (Schema<LowCopyProtostuffOutput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      ProtostuffIOUtil.mergeFrom((InputStream) null, (LowCopyProtostuffOutput) null, schema1);
      byte[] byteArray1 = new byte[4];
      byteArray1[0] = (byte) (-79);
      byteArray1[1] = (byte)102;
      byteArray1[2] = (byte) (-69);
      byteArray1[3] = (byte)0;
      CodedInput codedInput0 = CodedInput.newInstance(byteArray1);
      Schema<CodedInput> schema2 = (Schema<CodedInput>) mock(Schema.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        ProtostuffIOUtil.mergeDelimitedFrom((InputStream) null, codedInput0, schema2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("io.protostuff.IOUtil", e);
      }
  }
}
